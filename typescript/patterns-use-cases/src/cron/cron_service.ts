import * as restate from "@restatedev/restate-sdk";
import { CronExpressionParser } from "cron-parser";
import { InvocationId, serde, TerminalError } from "@restatedev/restate-sdk";

type JobRequest = {
  cronExpression: string; // The cron expression e.g. "0 0 * * *" (every day at midnight)
  service: string;
  method: string; // Handler to execute with this schedule
  key?: string; // Optional: Virtual Object key of task to call
  payload?: string; // Optional payload to pass to the handler
};

type JobInfo = {
  request: JobRequest;
  next_execution_time: string;
  next_execution_id: InvocationId;
};

// Key of the K/V state that we store in Restate
const JOB_STATE = "job-state";

/*
 * A distributed cron service built with Restate that schedules tasks based on cron expressions.
 *
 * Features:
 * - Create cron jobs with standard cron expressions (e.g., "0 0 * * *" for daily at midnight)
 * - Schedule any Restate service handler or virtual object method
 * - Guaranteed execution with Restate's durability
 * - Cancel and inspect running jobs
 *
 * Usage:
 * 1. Send requests to CronInitiator.create() to start new jobs
 * 2. Each job gets a unique ID and runs as a CronJob virtual object
 * 3. Jobs automatically reschedule themselves after each execution
 */
export const cronJobInitiator = restate.service({
  name: "CronJobInitiator",
  handlers: {
    create: async (ctx: restate.Context, request: JobRequest) => {
      // Create a new job ID and initiate the cron job object for that ID
      // We can then address this job object by its ID
      const jobId = ctx.rand.uuidv4();
      const job = await ctx.objectClient(cronJob, jobId).initiate(request);
      return `Job created with ID ${jobId} and next execution time ${job.next_execution_time}`;
    },
  },
});

export const cronJob = restate.object({
  name: "CronJob",
  handlers: {
    initiate: async (ctx: restate.ObjectContext, request: JobRequest): Promise<JobInfo> => {
      if (await ctx.get<JobInfo>(JOB_STATE)) {
        throw new TerminalError("Job already exists for this ID.");
      }

      return await scheduleNextExecution(ctx, request);
    },
    execute: async (ctx: restate.ObjectContext) => {
      const jobState = await ctx.get<JobInfo>(JOB_STATE);
      if (!jobState) {
        throw new TerminalError("Job not found.");
      }

      // execute the task
      const { service, method, key, payload } = jobState.request;
      if (payload) {
        ctx.genericSend({
          service,
          method,
          parameter: payload,
          key,
          inputSerde: serde.json,
        });
      } else {
        ctx.genericSend({
          service,
          method,
          parameter: undefined,
          key,
          inputSerde: serde.empty,
        });
      }

      await scheduleNextExecution(ctx, jobState.request);
    },
    cancel: async (ctx: restate.ObjectContext) => {
      // Cancel the next execution
      const jobState = await ctx.get<JobInfo>(JOB_STATE);
      if (jobState) {
        ctx.cancel(jobState.next_execution_id);
      }

      // Clear the job state
      ctx.clearAll();
    },
    getInfo: restate.handlers.object.shared(async (ctx: restate.ObjectSharedContext) => {
      return ctx.get<JobInfo>(JOB_STATE);
    }),
  },
});

const scheduleNextExecution = async (
  ctx: restate.ObjectContext,
  request: JobRequest,
): Promise<JobInfo> => {
  // Parse cron expression
  // Persist current date in Restate for deterministic replay
  const currentDate = await ctx.date.now();
  let interval;
  try {
    interval = CronExpressionParser.parse(request.cronExpression, { currentDate });
  } catch (e) {
    throw new TerminalError(`Invalid cron expression: ${(e as Error).message}`);
  }

  const next = interval.next().toDate();
  const delay = next.getTime() - currentDate;

  // Schedule next execution for this job
  const thisJobId = ctx.key; // This got generated by the CronJobInitiator
  const handle = ctx.objectSendClient(cronJob, thisJobId, { delay }).execute();

  // Store the job information
  const jobState = {
    request,
    next_execution_time: next.toString(),
    next_execution_id: await handle.invocationId,
  };
  ctx.set<JobInfo>(JOB_STATE, jobState);
  return jobState;
};
