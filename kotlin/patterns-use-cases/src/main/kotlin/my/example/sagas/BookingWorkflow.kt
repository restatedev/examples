package my.example.sagas

import dev.restate.sdk.annotation.Workflow
import dev.restate.sdk.http.vertx.RestateHttpServer
import dev.restate.sdk.kotlin.*
import dev.restate.sdk.kotlin.endpoint.endpoint
import dev.restate.sdk.common.TerminalException
import kotlinx.serialization.Serializable
import my.example.sagas.activities.CarRentalBookingRequest
import my.example.sagas.activities.CarRentalService
import my.example.sagas.activities.CarRentalServiceClient // Client for Restate service; generated by Restate SDK
import my.example.sagas.activities.FlightBookingRequest
import my.example.sagas.activities.FlightService
import my.example.sagas.activities.FlightServiceClient // Client for Restate service; generated by Restate SDK
import my.example.sagas.activities.PaymentInfo
import my.example.sagas.activities.chargeCustomer
import my.example.sagas.activities.refundCustomer

@Serializable data class TravelBookingRequest(val flights: FlightBookingRequest,
                                              val car: CarRentalBookingRequest,
                                              val paymentInfo: PaymentInfo)

/*
Trip reservation workflow using sagas:
Restate infinitely retries failures, and recovers previous progress.
But for some types of failures, we don't want to retry but want to undo the previous actions and finish.

Restate guarantees the execution of your code. This makes it very easy to implement sagas.
We execute actions, and keep track of a list of undo actions.
When a terminal exception occurs (an exception we do not want to retry), Restate ensures execution of all compensations.

+------ Initialize compensations list ------+
                     |
                     v
+------------------ Try --------------------+
| 1. Reserve Flights & Register Undo        |
| 2. Reserve Car & Register Undo            |
| 3. Generate Payment ID & Register Refund  |
| 4. Perform Payment                        |
| 5. Confirm Flight Reservation             |
| 6. Confirm Car Reservation                |
+------------------ Catch ------------------+
| If TerminalException:                         |
|   Execute compensations in reverse order  |
| Rethrow error                             |
+--------------------------------------------+

Note: that the compensation logic is purely implemented in user code (no special Restate API)
 */
@Workflow
class BookingWorkflow {

    @Workflow
    suspend fun run(ctx: WorkflowContext, req: TravelBookingRequest) {

        // Create a list of compensations to run in case of a failure or cancellation.
        val compensations: MutableList<suspend () -> Unit> = mutableListOf()

        try {
            // Reserve the flights and let Restate remember the reservation ID
            // This sends an HTTP request via Restate to the Restate flights service
            val flightsRpcClient = FlightServiceClient.fromContext(ctx)
            val flightBookingId = flightsRpcClient.reserve(req.flights).await()
            // Use the flightBookingId to register the undo action for the flight reservation,
            // or later confirm the reservation.
            compensations.add { flightsRpcClient.cancel(flightBookingId).await() }

            // Reserve the car and let Restate remember the reservation ID
            val carRentalRpcClient = CarRentalServiceClient.fromContext(ctx)
            val carBookingId = carRentalRpcClient.reserve(req.car).await()
            // Register the compensation to undo the car rental reservation.
            compensations.add { carRentalRpcClient.cancel(carBookingId).await() }

            // Charge the payment; Generate a payment ID and store it in Restate
            val paymentId = ctx.random().nextUUID().toString()
            // Register the payment refund using the paymentId
            compensations.add { ctx.runBlock { refundCustomer(paymentId)} }
            // Do the payment using the paymentId as idempotency key
            ctx.runBlock { chargeCustomer(req.paymentInfo, paymentId)}

            // Confirm flight and car rental after payment done
            flightsRpcClient.confirm(flightBookingId).await()
            carRentalRpcClient.confirm(carBookingId).await()
        }
        // Terminal errors tell Restate not to retry, but to compensate and fail the workflow
        catch (e: TerminalException) {
            // Undo all the steps up to this point by running the compensations
            // Restate guarantees that all compensations are executed
            compensations.reversed().forEach {
                it()
            }

            throw TerminalException("Failed to reserve the trip: ${e.message}. Ran ${compensations.size} compensations.")
        }
    }
}

fun main() {
    RestateHttpServer.listen(endpoint {
        bind(BookingWorkflow())
        bind(FlightService())
        bind(CarRentalService())
    })
}
